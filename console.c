/* Standard includes. */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"

#include "FreeRTOS_CLI.h"
#include "FreeRTOSConfig.h"
#include "utils/uartstdio.h"
#include "console.h"

#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   1000

static const char * const pcWelcomeMessage =
		"FreeRTOS command server.\r\nType Help to view a list of registered commands.\r\n";
static void prvCommandConsoleTask(void *pvParameters);

void vStartCliTask(void)
{
	xTaskCreate(prvCommandConsoleTask, /* The function that implements the task. */
				"Console", /* Just a text name for the task to aid debugging. */
				configMINIMAL_STACK_SIZE, /* The stack size is defined in FreeRTOSConfig.h. */
				NULL, /* The task parameter, pointer to the connected socket */
				3, NULL); /* The task handle is not used. */
}

static void prvCommandConsoleTask(void *pvParameters)
{
	int8_t cRxedChar, cInputIndex = 0;
	BaseType_t xMoreDataToFollow;
	/* The input and output buffers are declared static to keep them off the stack. */
	static char pcOutputString[MAX_OUTPUT_LENGTH], pcInputString[MAX_INPUT_LENGTH];

	vRegisterCLICommands();

	/* Send a welcome message to the user knows they are connected. */
	UARTwrite(pcWelcomeMessage, strlen(pcWelcomeMessage));

	for (;;)
	{
		/* This implementation reads a single character at a time.  Wait in the
		 Blocked state until a character is received. */
		cRxedChar = UARTgetc();

		if (cRxedChar == '\n')
		{
			/* A newline character was received, so the input command stirng is
			 complete and can be processed.  Transmit a line separator, just to
			 make the output easier to read. */
			UARTwrite("\r\n", strlen("\r\n"));

			/* The command interpreter is called repeatedly until it returns
			 pdFALSE.  See the "Implementing a command" documentation for an
			 exaplanation of why this is. */
			do
			{
				/* Send the command string to the command interpreter.  Any
				 output generated by the command interpreter will be placed in the
				 pcOutputString buffer. */
				xMoreDataToFollow = FreeRTOS_CLIProcessCommand(pcInputString, /* The command string.*/
																pcOutputString, /* The output buffer. */
																MAX_OUTPUT_LENGTH/* The size of the output buffer. */
																);

				/* Write the output generated by the command interpreter to the
				 console. */
				UARTwrite(pcOutputString, strlen(pcOutputString));

			} while (xMoreDataToFollow != pdFALSE);

			/* All the strings generated by the input command have been sent.
			 Processing of the command is complete.  Clear the input string ready
			 to receive the next command. */
			cInputIndex = 0;
			memset(pcInputString, 0x00, MAX_INPUT_LENGTH);
		}
		else
		{
			/* The if() clause performs the processing after a newline character
			 is received.  This else clause performs the processing if any other
			 character is received. */

			if (cRxedChar == '\r')
			{
				/* Ignore carriage returns. */
			}
			else if (cRxedChar == '\b')
			{
				/* Backspace was pressed.  Erase the last character in the input
				 buffer - if there are any. */
				if (cInputIndex > 0)
				{
					cInputIndex--;
					pcInputString[cInputIndex] = '\0';
				}
			}
			else
			{
				/* A character was entered.  It was not a new line, backspace
				 or carriage return, so it is accepted as part of the input and
				 placed into the input buffer.  When a \n is entered the complete
				 string will be passed to the command interpreter. */
				if (cInputIndex < MAX_INPUT_LENGTH)
				{
					pcInputString[cInputIndex] = cRxedChar;
					cInputIndex++;
				}
			}
		}
	}
}
